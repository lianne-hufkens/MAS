import random
from tabulate import tabulate

#Number of item types M
#Number of sellers K
#Number of buyers N
#Number of auction rounds R
#Universal maximum starting price Smax
#Penalty factor E
#Indication whether “pure” of leveled commitment auctioning is used PureCommitment
#other...

roundCount = 1
auctionCount = 1

class Buyer:
    bidFactors = None
    bid = None
    lastWin = None
    def __init__(self, ID):
        self.ID = ID
        self.bidFactors = [random.uniform(1,5) for t in range(M)] #a seperate factor for each item type
    def setBid(self, startPrice, itemType):
        self.bid = self.bidFactors[itemType] * startPrice

class Seller:
    itemType = None
    startPrice = None
    lastWin = None
    def __init__(self, ID):
        self.ID = ID
    def setStartingPrice(self):
        self.startPrice = random.randint(1, Smax) #maybe turn this into float?
    def setItemType(self):
        global M
        self.itemType = random.randint(0, M-1)


def askInput(message, lowBound=None, highBound=None):
    if lowBound is None:
        lowBound = 0
    if highBound is None:
        highBound = 100
    while True:
        a = input(message)
        if a is not "":
            if a.isdigit() and int(a) > lowBound and int(a) <= highBound:
                return int(a)
            
def askBool(message):
    while True:
        a = input(message)
        if a is not "":
            if a.lower() in ["y", "yes", "t", "tr", "true", "1"]:
                return True
            else:
                return False


def createAllObjects(): #create all buyers and sellers
    global buyers, sellers
    buyers = [Buyer(b) for b in range(N)]
    sellers = [Seller(s) for s in range(K)]

def sortBidders(bidders):
    return sorted(bidders, key=lambda x: x.bid, reverse=True)
    
def getWinnerAndPrice(bidders, marketPrice): #get the winning bidder and the price they must pay
    biddersLeft = [b for b in bidders if b.bid < marketPrice]
    biddersLeft = sortBidders(biddersLeft)
    if len(biddersLeft) > 1:
        return biddersLeft[0], biddersLeft[1].bid
    elif len(biddersLeft) == 1:
        return biddersLeft[0], biddersLeft[0].bid
    else:
        return None, None

def runAllRounds():
    for r in range(R):
        runRound()

def runRound():
    global buyers, sellers, roundCount, auctionCount
    for s in sellers:
        s.setItemType() #sellers pick their item type
    roundOrder = [n for n in range(len(sellers))] 
    random.shuffle(roundOrder) #to get the turn order for the sellers
    participatingBuyers = [b for b in buyers] #all buyers participate at first
    for o in roundOrder:
         participatingBuyers = runAuction(sellers[o], participatingBuyers) #run an auction
    auctionCount = 1
    roundCount += 1

def runAuction(seller, bidders):
    global auctionCount
    if len(bidders) > 1: #at least two bidders are present
        win = False
        seller.setStartingPrice() #set starting price
        for b in buyers:
            b.setBid(seller.startPrice, seller.itemType) #make all bids
        marketPrice = sum(b.bid for b in bidders) / len(bidders) #calculate market price
        winner, winPrice = getWinnerAndPrice(bidders, marketPrice) #get the winning buyer and what they need to pay
        if winner is not None: #if there's a winner, record the price
            winner.lastWin = winPrice
            seller.lastWin = winPrice
            win = True            
        printAuctionResults(bidders, seller, marketPrice, win) #print the results for this auction
        auctionCount += 1
        if win:
            return [b for b in bidders if b is not winner] #winner is removed from list
        else:
            return bidders

def printAuctionResults(bidders, seller, marketPrice, win):
    s1 = "Round {} auction {}".format(roundCount, auctionCount)
    s2 = "Seller {} auctioned item type {} with starting price {}".format(seller.ID, seller.itemType, seller.startPrice)
    bidders = sortBidders(bidders)
    bids = [b.bid for b in bidders]
    bids.append(marketPrice)
    bids.sort(reverse=True)
    mpIndex = bids.index(marketPrice)
    biddersID = [b.ID for b in bidders]
    biddersID.insert(mpIndex, "Market Price")
    data = [biddersID, bids]
    data = list(map(list, zip(*data)))#transpose list of lists
    print()
    print(s1)
    print(s2)
    print(tabulate(data, headers=['Buyer #', 'Bid value'], tablefmt="fancy_grid", stralign="center"))
    if not win:
        print("This auction had no winner.")
        

#start of program run

M = askInput("How many item types? ")
K = askInput("How many sellers? ")
N = askInput("How many buyers? ", K)
R = askInput("How many auction rounds? ")
E = askInput("What is the penalty factor? ", 0, 1)
Smax = askInput("What is the universal maximum starting price? ")
PureCommitment = askBool("Is pure commitment used? ")
createAllObjects()
runAllRounds()
